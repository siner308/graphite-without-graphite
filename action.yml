name: 'Staq'
description: 'Stacked PR merge queue powered by GitHub Actions and PR comments. No CLI, no SaaS.'
author: 'siner308'

branding:
  icon: 'git-merge'
  color: 'purple'

inputs:
  token:
    description: >
      GitHub token for API calls and git operations.
      Use a PAT or GitHub App token to enable CI auto-trigger after force push.
    required: false
    default: ${{ github.token }}
  app-id:
    description: 'GitHub App ID. Used with app-private-key to generate an installation token.'
    required: false
    default: ''
  app-private-key:
    description: 'GitHub App private key. Used with app-id to generate an installation token.'
    required: false
    default: ''

runs:
  using: 'composite'
  steps:
    # ── Generate App token (optional) ──
    - name: Generate GitHub App token
      id: app-token
      if: inputs.app-id != '' && inputs.app-private-key != ''
      continue-on-error: true
      uses: actions/create-github-app-token@v1
      with:
        app-id: ${{ inputs.app-id }}
        private-key: ${{ inputs.app-private-key }}

    # ── PR opened/edited: post stack guide ──
    - name: Post or update stack guide
      if: github.event_name == 'pull_request'
      uses: actions/github-script@v7
      with:
        github-token: ${{ steps.app-token.outputs.token || inputs.token }}
        script: |
          const { owner, repo } = context.repo;
          const pr = context.payload.pull_request;
          const pattern = /<!-- stack-rebase:([\s\S]*?) -->/;
          const marker = '<!-- stack-guide -->';

          let children = null;
          const bodyMatch = (pr.body || '').match(pattern);
          if (bodyMatch) {
            try { children = JSON.parse(bodyMatch[1]).children; } catch {}
          }

          const { data: comments } = await github.rest.issues.listComments({
            owner, repo, issue_number: pr.number,
          });
          const existing = comments.find(c =>
            c.body.includes(marker) && c.user.type === 'Bot'
          );

          if (!children?.length) {
            if (existing) {
              await github.rest.issues.deleteComment({
                owner, repo, comment_id: existing.id,
              });
            }
            return;
          }

          const stack = [`#${pr.number} (\`${pr.head.ref}\`)`]
            .concat(children.map(c => `#${c.pr} (\`${c.branch}\`)`))
            .join(' → ');

          const guide = [
            marker,
            '### Staq',
            '',
            '| Command | Description |',
            '|---------|-------------|',
            '| `stack merge` | Merge this PR, restack children |',
            '| `stack merge-all` | Merge entire stack (requires all approved) |',
            '| `stack merge-all --force` | Merge entire stack (skip approval check) |',
            '| `stack restack` | Restack children without merging |',
            '',
            `**Stack:** ${stack}`,
          ].join('\n');

          if (existing) {
            await github.rest.issues.updateComment({
              owner, repo, comment_id: existing.id, body: guide,
            });
          } else {
            await github.rest.issues.createComment({
              owner, repo, issue_number: pr.number, body: guide,
            });
          }

    # ── Comment: parse stack command ──
    - name: Parse command
      id: cmd
      if: github.event_name == 'issue_comment'
      uses: actions/github-script@v7
      with:
        script: |
          const body = context.payload.comment.body.trim();
          const match = body.match(
            /^stack\s+(merge-all|merge|restack|help)\b(.*)$/i
          );
          if (!match) {
            core.setOutput('valid', 'false');
            return;
          }
          core.setOutput('valid', 'true');
          core.setOutput('command', match[1].toLowerCase());
          core.setOutput('force', String(match[2].includes('--force')));

    - name: React eyes
      if: steps.cmd.outputs.valid == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ steps.app-token.outputs.token || inputs.token }}
        script: |
          await github.rest.reactions.createForIssueComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            comment_id: context.payload.comment.id,
            content: 'eyes',
          });

    - name: Checkout
      if: steps.cmd.outputs.valid == 'true' && steps.cmd.outputs.command != 'help'
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ steps.app-token.outputs.token || inputs.token }}

    - name: Configure git
      if: steps.cmd.outputs.valid == 'true' && steps.cmd.outputs.command != 'help'
      shell: bash
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

    # ── Execute stack command ──
    - name: Execute stack command
      if: steps.cmd.outputs.valid == 'true'
      id: run
      env:
        COMMAND: ${{ steps.cmd.outputs.command }}
        FORCE: ${{ steps.cmd.outputs.force }}
      uses: actions/github-script@v7
      with:
        github-token: ${{ steps.app-token.outputs.token || inputs.token }}
        script: |
          const { owner, repo } = context.repo;
          const prNumber = context.payload.issue.number;
          const command = process.env.COMMAND;
          const force = process.env.FORCE === 'true';

          // ════════════════════════════════════════
          // Helpers
          // ════════════════════════════════════════

          async function getStackMeta(prNum) {
            const { data: pr } = await github.rest.pulls.get({
              owner, repo, pull_number: prNum,
            });
            const pat = /<!-- stack-rebase:([\s\S]*?) -->/;

            const m = (pr.body || '').match(pat);
            if (m) {
              try { return { meta: JSON.parse(m[1]), pr }; } catch {}
            }

            const { data: comments } = await github.rest.issues.listComments({
              owner, repo, issue_number: prNum,
            });
            for (const c of comments) {
              const cm = (c.body || '').match(pat);
              if (cm) {
                try { return { meta: JSON.parse(cm[1]), pr }; } catch {}
              }
            }
            return { meta: null, pr };
          }

          async function isApproved(prNum) {
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner, repo, pull_number: prNum,
            });
            const latest = {};
            for (const r of reviews) {
              if (!r.user) continue;
              const u = r.user.login;
              if (
                !latest[u] ||
                new Date(r.submitted_at) > new Date(latest[u].submitted_at)
              ) {
                latest[u] = r;
              }
            }
            const vals = Object.values(latest);
            return (
              vals.some(r => r.state === 'APPROVED') &&
              !vals.some(r => r.state === 'CHANGES_REQUESTED')
            );
          }

          async function tryMerge(prNum, method = 'squash', retries = 0) {
            for (let i = 0; i <= retries; i++) {
              try {
                const { data } = await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: prNum,
                  merge_method: method,
                });
                return { ok: true, sha: data.sha };
              } catch (e) {
                const msg = e.message || '';
                const retryable =
                  /required status|pending|expected|head branch was modified/i.test(
                    msg
                  );
                if (retryable && i < retries) {
                  console.log(
                    `  #${prNum} attempt ${i + 1}: ${msg}. Retry in 30s...`
                  );
                  await new Promise(r => setTimeout(r, 30000));
                  continue;
                }
                return { ok: false, error: msg };
              }
            }
          }

          async function doRestack(branch, onto, skip) {
            try {
              await exec.exec('git', ['checkout', onto, '--detach'], {
                silent: true,
              });
              await exec.exec('git', [
                'rebase', '--onto', onto, skip, branch,
              ]);
              await exec.exec('git', [
                'push', '--force-with-lease', 'origin', branch,
              ]);
              return { ok: true };
            } catch (e) {
              try {
                await exec.exec('git', ['rebase', '--abort']);
              } catch {}
              return { ok: false, error: String(e) };
            }
          }

          async function post(prNum, body) {
            await github.rest.issues.createComment({
              owner, repo, issue_number: prNum, body,
            });
          }

          async function getOldTip(branch) {
            try {
              const { stdout } = await exec.getExecOutput('git', [
                'rev-parse', `origin/${branch}`,
              ]);
              return stdout.trim();
            } catch {
              return null;
            }
          }

          async function ensureLocalBranch(branch) {
            await exec
              .exec('git', ['branch', branch, `origin/${branch}`])
              .catch(() => {});
          }

          // ════════════════════════════════════════
          // Restack logic
          // ════════════════════════════════════════

          // All items in children array are siblings (direct children).
          // No chaining — each rebases onto the same parent.
          async function restackChildren(children, baseBranch, initialSkip, { parentBranch = null } = {}) {
            await exec.exec('git', ['fetch', 'origin']);

            const merged = !parentBranch;
            const ontoBase = parentBranch ? `origin/${parentBranch}` : `origin/${baseBranch}`;
            const results = [];

            for (const child of children) {
              const oldTip = await getOldTip(child.branch);

              if (!oldTip) {
                results.push({ ...child, status: 'missing' });
                continue;
              }

              await ensureLocalBranch(child.branch);
              const r = await doRestack(child.branch, ontoBase, initialSkip);

              if (r.ok) {
                results.push({ ...child, status: 'restacked', oldTip });
              } else {
                results.push({
                  ...child, status: 'conflict', oldTip, error: r.error,
                });
              }
            }

            // After parent is merged, update all children's base to main
            if (merged) {
              for (const r of results) {
                if (r.status === 'restacked') {
                  await github.rest.pulls
                    .update({
                      owner, repo, pull_number: r.pr, base: baseBranch,
                    })
                    .catch(() => {});
                }
              }
            }

            return results;
          }

          function formatResults(results, baseBranch, skipSha, { parentBranch = null } = {}) {
            const label = {
              restacked: 'Restacked',
              merged: 'Merged',
              conflict: 'Conflict',
              missing: 'Branch not found',
              skipped: 'Skipped',
              merge_failed: 'Merge failed',
            };
            const rows = results.map(
              r =>
                `| \`${r.branch}\` | #${r.pr} | ${label[r.status] || r.status} |`
            );

            const failed = results.filter(
              r => !['restacked', 'merged'].includes(r.status) && r.oldTip
            );
            let manual = '';
            if (failed.length) {
              const ontoTarget = parentBranch ? `origin/${parentBranch}` : `origin/${baseBranch}`;
              const cmds = ['git fetch origin', ''];
              for (const r of failed) {
                cmds.push(`# ${r.branch} (PR #${r.pr})`);
                cmds.push(
                  `git rebase --onto ${ontoTarget} ${skipSha.substring(0, 8)} ${r.branch}`
                );
                cmds.push('# resolve conflicts if any, then:');
                cmds.push(
                  `git push --force-with-lease origin ${r.branch}`
                );
                cmds.push('');
              }
              manual = [
                '',
                '<details><summary>Manual restack commands</summary>',
                '',
                '```bash',
                ...cmds,
                '```',
                '</details>',
              ].join('\n');
            }

            return [
              '| Branch | PR | Status |',
              '|--------|-----|--------|',
              ...rows,
              manual,
            ].join('\n');
          }

          // ════════════════════════════════════════
          // Command dispatch
          // ════════════════════════════════════════

          const { meta, pr } = await getStackMeta(prNumber);
          const baseBranch = pr.base.ref;
          const children = meta?.children || [];
          const mergeMethod = meta?.merge_method || 'squash';

          // ── help ──
          if (command === 'help') {
            const stack = children.length
              ? [`#${prNumber} (\`${pr.head.ref}\`)`]
                  .concat(
                    children.map(c => `#${c.pr} (\`${c.branch}\`)`)
                  )
                  .join(' → ')
              : '_No stack metadata found._';

            await post(prNumber, [
              '### Staq Commands',
              '',
              '| Command | Description |',
              '|---------|-------------|',
              '| `stack merge` | Merge this PR, restack children |',
              '| `stack merge-all` | Merge entire stack (requires approval) |',
              '| `stack merge-all --force` | Skip approval check |',
              '| `stack restack` | Restack children only |',
              '',
              `**Stack:** ${stack}`,
            ].join('\n'));
            return;
          }

          // ── restack ──
          if (command === 'restack') {
            if (!children.length) {
              await post(prNumber, 'No children to restack.');
              return;
            }

            const results = await restackChildren(
              children, baseBranch, pr.head.sha,
              { parentBranch: pr.head.ref }
            );
            const ok = results.every(r => r.status === 'restacked');

            await post(prNumber, [
              ok ? '### Restack: Complete' : '### Restack: Action Needed',
              '',
              formatResults(results, baseBranch, pr.head.sha, { parentBranch: pr.head.ref }),
            ].join('\n'));

            if (!ok) core.setFailed('Restack had failures');
            return;
          }

          // ── merge ──
          if (command === 'merge') {
            const merged = await tryMerge(prNumber, mergeMethod);
            if (!merged.ok) {
              await post(prNumber, `Merge failed: ${merged.error}`);
              core.setFailed(merged.error);
              return;
            }

            if (!children.length) {
              await post(prNumber, `Merged into \`${baseBranch}\`.`);
              return;
            }

            const results = await restackChildren(
              children, baseBranch, pr.head.sha
            );
            const ok = results.every(r => r.status === 'restacked');

            await post(prNumber, [
              ok
                ? '### Merged + Restacked'
                : '### Merged (restack needs attention)',
              '',
              `#${prNumber} merged into \`${baseBranch}\`.`,
              '',
              formatResults(results, baseBranch, pr.head.sha),
            ].join('\n'));

            for (const r of results) {
              await post(r.pr, [
                `#${prNumber} (\`${pr.head.ref}\`) was merged.`,
                r.status === 'restacked'
                  ? 'Your branch was automatically restacked.'
                  : `Restack status: **${r.status}**`,
              ].join(' ')).catch(() => {});
            }

            if (!ok) core.setFailed('Restack had failures');
            return;
          }

          // ── merge-all ──
          if (command === 'merge-all') {
            // Collect all PRs recursively (DFS)
            async function collectAllPRs(prNum) {
              const nums = [prNum];
              const { meta } = await getStackMeta(prNum);
              if (meta?.children) {
                for (const child of meta.children) {
                  nums.push(...(await collectAllPRs(child.pr)));
                }
              }
              return nums;
            }

            if (!force) {
              const allPRs = await collectAllPRs(prNumber);
              const unapproved = [];
              for (const n of allPRs) {
                if (!(await isApproved(n))) unapproved.push(n);
              }
              if (unapproved.length) {
                await post(prNumber, [
                  '### Cannot merge-all',
                  '',
                  `Not approved: ${unapproved.map(n => `#${n}`).join(', ')}`,
                  '',
                  'Use `stack merge-all --force` to skip approval check.',
                ].join('\n'));
                core.setFailed('Not all PRs approved');
                return;
              }
            }

            const first = await tryMerge(prNumber, mergeMethod);
            if (!first.ok) {
              await post(
                prNumber,
                `Merge failed for #${prNumber}: ${first.error}`
              );
              core.setFailed(first.error);
              return;
            }

            if (!children.length) {
              await post(
                prNumber,
                `Merged into \`${baseBranch}\`. (no children)`
              );
              return;
            }

            // Recursively merge children → grandchildren in DFS order
            const results = [];

            async function mergeChildren(childrenList, parentSkipSha) {
              for (const child of childrenList) {
                await exec.exec('git', ['fetch', 'origin']);

                const oldTip = await getOldTip(child.branch);
                if (!oldTip) {
                  results.push({ ...child, status: 'missing' });
                  continue;
                }

                await ensureLocalBranch(child.branch);

                const rs = await doRestack(
                  child.branch, `origin/${baseBranch}`, parentSkipSha
                );
                if (!rs.ok) {
                  results.push({
                    ...child, status: 'conflict', oldTip, error: rs.error,
                  });
                  continue;
                }

                await github.rest.pulls
                  .update({
                    owner, repo, pull_number: child.pr, base: baseBranch,
                  })
                  .catch(() => {});

                console.log(
                  `Waiting for CI on #${child.pr} (${child.branch})...`
                );
                const merged = await tryMerge(child.pr, mergeMethod, 20);

                if (!merged.ok) {
                  results.push({
                    ...child,
                    status: 'merge_failed',
                    oldTip,
                    error: merged.error,
                  });
                  continue;
                }

                results.push({ ...child, status: 'merged', oldTip });

                // Recursively process this child's children
                const { meta: childMeta } = await getStackMeta(child.pr);
                if (childMeta?.children?.length) {
                  await mergeChildren(childMeta.children, oldTip);
                }
              }
            }

            await mergeChildren(children, pr.head.sha);

            const allMerged = results.every(r => r.status === 'merged');
            const mergedCount =
              results.filter(r => r.status === 'merged').length + 1;
            const total = results.length + 1;

            const rows = results.map(r => {
              const st = {
                merged: 'Merged',
                conflict: 'Conflict',
                merge_failed: `Merge failed: ${r.error || ''}`,
                missing: 'Branch not found',
                skipped: 'Skipped',
              }[r.status] || r.status;
              return `| \`${r.branch}\` | #${r.pr} | ${st} |`;
            });

            await post(prNumber, [
              allMerged
                ? `### Stack Merged (${mergedCount}/${total})`
                : `### Stack Merge: Stopped (${mergedCount}/${total} merged)`,
              '',
              '| Branch | PR | Status |',
              '|--------|-----|--------|',
              `| \`${pr.head.ref}\` | #${prNumber} | Merged |`,
              ...rows,
              '',
              !allMerged
                ? 'Fix the issue and run `stack merge` on the failed PR.'
                : '',
            ].join('\n'));

            if (!allMerged) core.setFailed('Not all PRs merged');
            return;
          }

    # ── Result reaction ──
    - name: Result reaction
      if: always() && steps.cmd.outputs.valid == 'true'
      uses: actions/github-script@v7
      with:
        github-token: ${{ steps.app-token.outputs.token || inputs.token }}
        script: |
          await github.rest.reactions.createForIssueComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            comment_id: context.payload.comment.id,
            content:
              '${{ steps.run.outcome }}' === 'success'
                ? 'rocket'
                : 'confused',
          });
